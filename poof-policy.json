{
  "uniblock/$requestId": {
    "type": "api",
    "service": "uniblock",
    "rules": {
      "create": "true",
      "update": "true",
      "delete": "true"
    }
  },
  "appFiles/$fileId": {
    "type": "storage",
    "rules": {
      "read": "true",
      "create": "true",
      "update": "false",
      "delete": "false"
    }
  },
  "uploadedImages/$imageId": {
    "type": "storage",
    "description": "User uploaded images ad files",
    "rules": {
      "read": "true",
      "create": "@user.address == @constants.ADMIN_ADDRESS",
      "update": "false",
      "delete": "@user.address == @constants.ADMIN_ADDRESS"
    }
  },
  "markets/$marketId": {
    "operationDetails": {
      "read": "UI/API How-To:\nWho: Anyone.\nGoal: View a market's data (question, totals, status).\nPreconditions: None.\nSteps (client):\n  1) Read markets/$marketId.\nHooks that will execute (on success): None.\nPostconditions: None.\nWhat the client should do next:\n  - Compute odds from totalYesBets & totalNoBets.\nNotes:\n  - Idempotency: Reads are safe to retry.",
      "create": "UI/API How-To:\nWho: Admin only ('Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q').\nGoal: Create a new prediction market.\nPreconditions:\n  - @user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q'\n  - @newData.question != null\n  - @newData.resolutionDate > @time.now\nSteps (client):\n  1) Generate unique $marketId.\n  2) Create markets/$marketId with fields: { question, category (optional), resolutionDate, status: 'active', outcome: 'pending', totalYesBets: 0, totalNoBets: 0 }.\nHooks that will execute (on success): @AccountPlugin.createAccount($marketId) to establish escrow.\nPostconditions: Market live; escrow PDA created.\nWhat the client should do next:\n  - Render in active markets list.\nNotes:\n  - Units: resolutionDate is Unix seconds.\n  - Idempotency: Reuse same $marketId to retry safely.",
      "update": "UI/API How-To:\nWho: Admin only.\nGoal: Resolve a market.\nPreconditions:\n  - @user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q'\n  - @data.status == 'active'\n  - @newData.status == 'resolved'\n  - (@newData.outcome == 'yes' || @newData.outcome == 'no' || @newData.outcome == 'cancelled')\nSteps (client):\n  1) Update markets/$marketId with status='resolved' and outcome set.\nHooks that will execute (on success): None (users claim individually).\nPostconditions: Market locked; users can claim.\nWhat the client should do next:\n  - Notify bettors to claim winnings.\nNotes:\n  - Idempotency: Repeating same update is safe.",
      "delete": "UI/API How-To:\nWho: N/A.\nGoal: Not supported."
    },
    "onchain": true,
    "fields": {
      "question": "String",
      "category": "String?",
      "resolutionDate": "UInt",
      "status": "String",
      "outcome": "String",
      "totalYesBets": "UInt",
      "totalNoBets": "UInt"
    },
    "rules": {
      "read": "true",
      "create": "@user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q' && @newData.question != null && @newData.resolutionDate > @time.now && @newData.status == 'active' && @newData.outcome == 'pending' && @newData.totalYesBets == 0 && @newData.totalNoBets == 0",
      "update": "@user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q' && @data.status == 'active' && @newData.status == 'resolved' && (@newData.outcome == 'yes' || @newData.outcome == 'no' || @newData.outcome == 'cancelled')",
      "delete": "false"
    },
    "hooks": {
      "onchain": {
        "create": "@AccountPlugin.createAccount($marketId)"
      }
    },
    "queries": {
      "getEscrowSolBalance": {
        "returnType": "UInt",
        "query": "@TokenPlugin.getBalance($marketId, @TokenPlugin.SOL)"
      }
    }
  },
  "markets/$marketId/bets/$betId": {
    "operationDetails": {
      "read": "UI/API How-To:\nWho: Anyone.\nGoal: View a single bet.\nPreconditions: None.",
      "create": "UI/API How-To:\nWho: Authenticated user; caller must equal @newData.bettor.\nGoal: Place a bet on a market.\nPreconditions:\n  - @newData.bettor == @user.address\n  - @newData.amount >= 1000000\n  - (@newData.position == 'yes' || @newData.position == 'no')\n  - get(/markets/$marketId).status == 'active'\n  - @time.now < get(/markets/$marketId).resolutionDate\nSteps (client):\n  1) Generate $betId.\n  2) Create markets/$marketId/bets/$betId with { bettor, position, amount, resolved:false }.\nHooks that will execute (on success):\n  - Transfer SOL from bettor to market escrow.\n  - Increment market totals atomically.\nPostconditions: Bet escrowed.\nNotes: Units lamports; idempotent by reusing $betId.",
      "update": "Not supported (use claims path).",
      "delete": "Not supported."
    },
    "onchain": true,
    "isPassthrough": true,
    "fields": {
      "bettor": "Address",
      "position": "String",
      "amount": "UInt",
      "resolved": "Bool"
    },
    "rules": {
      "read": "true",
      "create": "@newData.bettor == @user.address && @newData.amount >= 1000000 && (@newData.position == 'yes' || @newData.position == 'no') && get(/markets/$marketId).status == 'active' && @time.now < get(/markets/$marketId).resolutionDate",
      "update": "false",
      "delete": "false"
    },
    "hooks": {
      "onchain": {
        "create": "@TokenPlugin.transfer(@user.address, $marketId, @TokenPlugin.SOL, @newData.amount) && ( (@newData.position == 'yes' && @DocumentPlugin.updateField(/markets/$marketId, 'totalYesBets', get(/markets/$marketId).totalYesBets + @newData.amount)) || (@newData.position == 'no' && @DocumentPlugin.updateField(/markets/$marketId, 'totalNoBets', get(/markets/$marketId).totalNoBets + @newData.amount)) )"
      }
    }
  },
  "markets/$marketId/bets/$betId/claims/$claimId": {
    "operationDetails": {
      "read": "UI/API How-To:\nWho: Anyone (audit/history).\nGoal: View claim attempts.",
      "create": "UI/API How-To:\nWho: Bet owner (@user.address must equal bet.bettor).\nGoal: Claim winnings after market resolution.\nPreconditions:\n  - get(/markets/$marketId/bets/$betId).bettor == @user.address\n  - get(/markets/$marketId/bets/$betId).resolved == false\n  - get(/markets/$marketId).status == 'resolved'\nSteps (client):\n  1) Create markets/$marketId/bets/$betId/claims/$claimId with empty body {}.\nHooks that will execute (on success): payout transfer if win & mark bet resolved.\nPostconditions: Bet resolved; payout transferred if applicable.",
      "update": "Not supported.",
      "delete": "Not supported."
    },
    "onchain": true,
    "isPassthrough": true,
    "fields": {},
    "rules": {
      "read": "true",
      "create": "get(/markets/$marketId/bets/$betId).bettor == @user.address && get(/markets/$marketId/bets/$betId).resolved == false && get(/markets/$marketId).status == 'resolved'",
      "update": "false",
      "delete": "false"
    },
    "hooks": {
      "onchain": {
        "create": "( (get(/markets/$marketId).outcome == 'yes' && get(/markets/$marketId/bets/$betId).position == 'yes' && @TokenPlugin.transfer($marketId, @user.address, @TokenPlugin.SOL, ( get(/markets/$marketId/bets/$betId).amount * (get(/markets/$marketId).totalYesBets + get(/markets/$marketId).totalNoBets) // get(/markets/$marketId).totalYesBets ) ) ) || (get(/markets/$marketId).outcome == 'no' && get(/markets/$marketId/bets/$betId).position == 'no' && @TokenPlugin.transfer($marketId, @user.address, @TokenPlugin.SOL, ( get(/markets/$marketId/bets/$betId).amount * (get(/markets/$marketId).totalYesBets + get(/markets/$marketId).totalNoBets) // get(/markets/$marketId).totalNoBets ) ) ) || true) && @DocumentPlugin.updateField(/markets/$marketId/bets/$betId, 'resolved', true)"
      }
    }
  }
}