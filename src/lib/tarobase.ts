// Generated by TaroBase SDK Generator: 2025-10-04T20:12:54.964Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@tarobase/js-sdk';
import { getFiles, setFile } from '@tarobase/js-sdk';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@tarobase/js-sdk'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

export type TokenName = 'USDC' | 'SOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * @param key A PublicKey instance or a base58 encoded public key string.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    let pkInstance: PublicKey;
    if (typeof key === 'string') {
      try {
        // Validate and create PublicKey from string
        pkInstance = new PublicKey(key);
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}`);
      }
    } else if (key instanceof PublicKey) {
       // Use the provided PublicKey instance directly
      pkInstance = key;
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
    // Return the structured AddressType object
    return {
      type: 'address',
      publicKey: pkInstance,
    };
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Generated Functions by Policy Path ---

// --- Path: uniblock/$requestId ---

// --- Path: uniblock/$requestId --- (Uniblock – typed wrappers, hard‑coded requestId=1)

export type UniblockChainId =
  | 'solana'
  | 'solana-devnet'
  | 1 | 8453 | 42161 | number;

export interface WalletTokenBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletTokenBalanceResponseItem { contractAddress: string; balance: string; name: string; symbol: string; logo: string; decimals: string; }
export interface WalletTokenBalanceResponse { balances: WalletTokenBalanceResponseItem[]; }
export async function getWalletTokenBalance({ walletAddress, chainId = 'solana' }: WalletTokenBalanceParams): Promise<WalletTokenBalanceResponse> {
  const body = { operationId: 'WalletTokenBalance', operationInputData: { walletAddress, chainId, includePrice: true } };
  return (await set("uniblock/1", body)) as WalletTokenBalanceResponse;
}

export interface TokenPriceParams { contractAddress: string; chainId?: UniblockChainId; }
export interface TokenPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; }
export async function getTokenPrice({ contractAddress, chainId = 'solana' }: TokenPriceParams): Promise<TokenPriceResponse> {
  const body = { operationId: 'TokenPrice', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenPriceResponse;
}

export interface TokenHistoricalPriceParams { contractAddress: string; chainId?: UniblockChainId; timestamp?: number; blockNumber?: number; }
export interface TokenHistoricalPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; blockNumber: string; timestamp: string; }
export async function getTokenHistoricalPrice({ contractAddress, chainId = 'solana', timestamp, blockNumber }: TokenHistoricalPriceParams): Promise<TokenHistoricalPriceResponse> {
  const body = { operationId: 'TokenHistoricalPrice', operationInputData: { contractAddress, chainId, timestamp, blockNumber } };
  return (await set("uniblock/1", body)) as TokenHistoricalPriceResponse;
}

export interface WalletNFTBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletNFTBalanceResponseItem { contractAddress: string; tokenId: string; name: string; symbol: string; image: string; }
export interface WalletNFTBalanceResponse { balances: WalletNFTBalanceResponseItem[]; }
export async function getWalletNFTBalance({ walletAddress, chainId = 'solana' }: WalletNFTBalanceParams): Promise<WalletNFTBalanceResponse> {
  const body = { operationId: 'WalletNFTBalance', operationInputData: { walletAddress, chainId } };
  return (await set("uniblock/1", body)) as WalletNFTBalanceResponse;
}

export interface NFTCollectionMetadataParams { contractAddress: string; chainId?: UniblockChainId; }
export interface NFTCollectionMetadataResponse { address: string; name: string; symbol: string; type: string; }
export async function getNFTCollectionMetadata({ contractAddress, chainId = 'solana' }: NFTCollectionMetadataParams): Promise<NFTCollectionMetadataResponse> {
  const body = { operationId: 'NFTCollectionMetadata', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as NFTCollectionMetadataResponse;
}

export interface NFTMetadataParams { contractAddress: string; tokenId: string; chainId?: UniblockChainId; }
export interface NFTMetadataResponse { contractAddress: string; contractType: string; metadata: any; rawMetadata: string; lastUpdated: string; contractMetadata: any; }
export async function getNFTMetadata({ contractAddress, tokenId, chainId = 'solana' }: NFTMetadataParams): Promise<NFTMetadataResponse> {
  const body = { operationId: 'NFTMetadata', operationInputData: { contractAddress, tokenId, chainId } };
  return (await set("uniblock/1", body)) as NFTMetadataResponse;
}

export interface TokenMetadataParams { tokenAddress: string; chainId?: UniblockChainId; }
export interface TokenMetadataResponse { name: string; symbol: string; logo: string; decimals: string; }
export async function getTokenMetadata({ tokenAddress, chainId = 'solana' }: TokenMetadataParams): Promise<TokenMetadataResponse> {
  const body = { operationId: 'TokenMetadata', operationInputData: { tokenAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenMetadataResponse;
}
// --- Path: appFiles/$fileId ---

/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`appFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 */
export async function uploadAppFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `appFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: uploadedImages/$imageId ---

/**
 * Handles UploadedImages files (Get Single File based on its ID, null if not found)
 */
export async function getUploadedImages(imageId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`uploadedImages/${imageId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles UploadedImages files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getUploadedImages function right after this one.
 */
export async function uploadUploadedImages(imageId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `uploadedImages/${imageId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Handles UploadedImages files (Delete File based on its ID, returns true if successful)
 */
export async function deleteUploadedImages(imageId: string): Promise<boolean> {
  try {
    await setFile(`uploadedImages/${imageId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: markets/$marketId ---

export interface MarketsRequest {
  question: string;
  category?: string;
  resolutionDate: number | TimeOperation | TokenAmount;
  status: string;
  outcome: string;
  totalYesBets: number | TimeOperation | TokenAmount;
  totalNoBets: number | TimeOperation | TokenAmount;
}

export interface MarketsResponse {
  question: string;
  category?: string;
  resolutionDate: number;
  status: string;
  outcome: string;
  totalYesBets: number;
  totalNoBets: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a Markets operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildMarkets(marketId: string, data: MarketsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `markets/${marketId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Admin only ('Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q').
Goal: Create a new prediction market.
Preconditions:
  - @user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q'
  - @newData.question != null
  - @newData.resolutionDate > @time.now
Steps (client):
  1) Generate unique $marketId.
  2) Create markets/$marketId with fields: { question, category (optional), resolutionDate, status: 'active', outcome: 'pending', totalYesBets: 0, totalNoBets: 0 }.
Hooks that will execute (on success): @AccountPlugin.createAccount($marketId) to establish escrow.
Postconditions: Market live; escrow PDA created.
What the client should do next:
  - Render in active markets list.
Notes:
  - Units: resolutionDate is Unix seconds.
  - Idempotency: Reuse same $marketId to retry safely. (Create/Update Single Item)
 */
export async function setMarkets(marketId: string, data: MarketsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`markets/${marketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Markets: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type MarketsRequestUpdate = Partial<MarketsRequest>;

/**
 * Build a Markets update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateMarkets(marketId: string, data: MarketsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `markets/${marketId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Admin only.
Goal: Resolve a market.
Preconditions:
  - @user.address == 'Cgkg49NwM9S5vAowZEfnCHR6K3P4brE6brbzJM5eRX2q'
  - @data.status == 'active'
  - @newData.status == 'resolved'
  - (@newData.outcome == 'yes' || @newData.outcome == 'no' || @newData.outcome == 'cancelled')
Steps (client):
  1) Update markets/$marketId with status='resolved' and outcome set.
Hooks that will execute (on success): None (users claim individually).
Postconditions: Market locked; users can claim.
What the client should do next:
  - Notify bettors to claim winnings.
Notes:
  - Idempotency: Repeating same update is safe. (Update Single Item)
 */
export async function updateMarkets(marketId: string, data: MarketsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`markets/${marketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating Markets: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
   (Get Single Item)
 */
export async function getMarkets(marketId: string): Promise<MarketsResponse | null> {
  try {
    const result = await get(`markets/${marketId}`);
    return result as MarketsResponse | null;
  } catch (error) {
    console.error(`Error getting Markets: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Markets document. (
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
  )
 */
export function subscribeMarkets(callback: (data: MarketsResponse | null) => void, marketId: string): Promise<() => Promise<void>> {
  return subscribe(`markets/${marketId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as MarketsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Markets at path '${`markets/${marketId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Markets items from collection markets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
  
 */
export async function getManyMarkets(filter: string = ""): Promise<MarketsResponse[]> {
  try {
    const results = await get("markets", { prompt: filter });
    return Array.isArray(results) ? results as MarketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Markets collection at path 'markets': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Markets collection at markets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
  
 */
export function subscribeManyMarkets(callback: (data: MarketsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("markets", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Markets collection at path '${"markets"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all Markets items from collection markets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
  
 */
export async function getAllMarkets(filter: string = ""): Promise<MarketsResponse[]> {
  try {
    const results = await get("markets", { prompt: filter });
    return Array.isArray(results) ? results as MarketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Markets collection at path 'markets': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Markets collection at markets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a market's data (question, totals, status).
Preconditions: None.
Steps (client):
  1) Read markets/$marketId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Compute odds from totalYesBets & totalNoBets.
Notes:
  - Idempotency: Reads are safe to retry.
  
 */
export function subscribeAllMarkets(callback: (data: MarketsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("markets", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Markets collection at path '${"markets"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getEscrowSolBalance" query on Markets.
 * Query Logic: @TokenPlugin.getBalance($marketId, @TokenPlugin.SOL)
 */
export async function runGetEscrowSolBalanceQueryForMarkets(marketId: string, ): Promise<number> {
  try {
    const result = await runQuery(`markets/${marketId}`, "getEscrowSolBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getEscrowSolBalance" on Markets: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: markets/$marketId/bets/$betId ---

export interface MarketsBetsRequest {
  bettor: AddressType;
  position: string;
  amount: number | TimeOperation | TokenAmount;
  resolved: boolean;
}

export interface MarketsBetsResponse {
  bettor: string;
  position: string;
  amount: number;
  resolved: boolean;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a MarketsBets operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildMarketsBets(marketId: string, betId: string, data: MarketsBetsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `markets/${marketId}/bets/${betId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Authenticated user; caller must equal @newData.bettor.
Goal: Place a bet on a market.
Preconditions:
  - @newData.bettor == @user.address
  - @newData.amount >= 1000000
  - (@newData.position == 'yes' || @newData.position == 'no')
  - get(/markets/$marketId).status == 'active'
  - @time.now < get(/markets/$marketId).resolutionDate
Steps (client):
  1) Generate $betId.
  2) Create markets/$marketId/bets/$betId with { bettor, position, amount, resolved:false }.
Hooks that will execute (on success):
  - Transfer SOL from bettor to market escrow.
  - Increment market totals atomically.
Postconditions: Bet escrowed.
Notes: Units lamports; idempotent by reusing $betId. (Create/Update Single Item)
 */
export async function setMarketsBets(marketId: string, betId: string, data: MarketsBetsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`markets/${marketId}/bets/${betId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting MarketsBets: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
   (Get Single Item)
 */
export async function getMarketsBets(marketId: string, betId: string): Promise<MarketsBetsResponse | null> {
  try {
    const result = await get(`markets/${marketId}/bets/${betId}`);
    return result as MarketsBetsResponse | null;
  } catch (error) {
    console.error(`Error getting MarketsBets: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single MarketsBets document. (
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
  )
 */
export function subscribeMarketsBets(callback: (data: MarketsBetsResponse | null) => void, marketId: string, betId: string): Promise<() => Promise<void>> {
  return subscribe(`markets/${marketId}/bets/${betId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as MarketsBetsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to MarketsBets at path '${`markets/${marketId}/bets/${betId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many MarketsBets items from collection markets/${marketId}/bets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
  
 */
export async function getManyMarketsBets(marketId: string, filter: string = ""): Promise<MarketsBetsResponse[]> {
  try {
    const results = await get(`markets/${marketId}/bets`, { prompt: filter });
    return Array.isArray(results) ? results as MarketsBetsResponse[] : [];
  } catch (error) {
    console.error(`Error getting MarketsBets collection at path 'markets/${marketId}/bets': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in MarketsBets collection at markets/${marketId}/bets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
  
 */
export function subscribeManyMarketsBets(callback: (data: MarketsBetsResponse[]) => void, marketId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`markets/${marketId}/bets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsBetsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to MarketsBets collection at path '${`markets/${marketId}/bets`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all MarketsBets items from collection markets/${marketId}/bets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
  
 */
export async function getAllMarketsBets(marketId: string, filter: string = ""): Promise<MarketsBetsResponse[]> {
  try {
    const results = await get(`markets/*/bets`, { prompt: filter });
    return Array.isArray(results) ? results as MarketsBetsResponse[] : [];
  } catch (error) {
    console.error(`Error getting MarketsBets collection at path 'markets/${marketId}/bets': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in MarketsBets collection at markets/${marketId}/bets
 
  Read Operation Details: UI/API How-To:
Who: Anyone.
Goal: View a single bet.
Preconditions: None.
  
 */
export function subscribeAllMarketsBets(callback: (data: MarketsBetsResponse[]) => void, marketId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`markets/*/bets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsBetsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to MarketsBets collection at path '${`markets/*/bets`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: markets/$marketId/bets/$betId/claims/$claimId ---

export interface MarketsBetsClaimsRequest {

}

export interface MarketsBetsClaimsResponse {

  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a MarketsBetsClaims operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildMarketsBetsClaims(marketId: string, betId: string, claimId: string, data: MarketsBetsClaimsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `markets/${marketId}/bets/${betId}/claims/${claimId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Bet owner (@user.address must equal bet.bettor).
Goal: Claim winnings after market resolution.
Preconditions:
  - get(/markets/$marketId/bets/$betId).bettor == @user.address
  - get(/markets/$marketId/bets/$betId).resolved == false
  - get(/markets/$marketId).status == 'resolved'
Steps (client):
  1) Create markets/$marketId/bets/$betId/claims/$claimId with empty body {}.
Hooks that will execute (on success): payout transfer if win & mark bet resolved.
Postconditions: Bet resolved; payout transferred if applicable. (Create/Update Single Item)
 */
export async function setMarketsBetsClaims(marketId: string, betId: string, claimId: string, data: MarketsBetsClaimsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`markets/${marketId}/bets/${betId}/claims/${claimId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting MarketsBetsClaims: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
   (Get Single Item)
 */
export async function getMarketsBetsClaims(marketId: string, betId: string, claimId: string): Promise<MarketsBetsClaimsResponse | null> {
  try {
    const result = await get(`markets/${marketId}/bets/${betId}/claims/${claimId}`);
    return result as MarketsBetsClaimsResponse | null;
  } catch (error) {
    console.error(`Error getting MarketsBetsClaims: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single MarketsBetsClaims document. (
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
  )
 */
export function subscribeMarketsBetsClaims(callback: (data: MarketsBetsClaimsResponse | null) => void, marketId: string, betId: string, claimId: string): Promise<() => Promise<void>> {
  return subscribe(`markets/${marketId}/bets/${betId}/claims/${claimId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as MarketsBetsClaimsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to MarketsBetsClaims at path '${`markets/${marketId}/bets/${betId}/claims/${claimId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many MarketsBetsClaims items from collection markets/${marketId}/bets/${betId}/claims
 
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
  
 */
export async function getManyMarketsBetsClaims(marketId: string, betId: string, filter: string = ""): Promise<MarketsBetsClaimsResponse[]> {
  try {
    const results = await get(`markets/${marketId}/bets/${betId}/claims`, { prompt: filter });
    return Array.isArray(results) ? results as MarketsBetsClaimsResponse[] : [];
  } catch (error) {
    console.error(`Error getting MarketsBetsClaims collection at path 'markets/${marketId}/bets/${betId}/claims': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in MarketsBetsClaims collection at markets/${marketId}/bets/${betId}/claims
 
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
  
 */
export function subscribeManyMarketsBetsClaims(callback: (data: MarketsBetsClaimsResponse[]) => void, marketId: string, betId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`markets/${marketId}/bets/${betId}/claims`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsBetsClaimsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to MarketsBetsClaims collection at path '${`markets/${marketId}/bets/${betId}/claims`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all MarketsBetsClaims items from collection markets/${marketId}/bets/${betId}/claims
 
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
  
 */
export async function getAllMarketsBetsClaims(marketId: string, betId: string, filter: string = ""): Promise<MarketsBetsClaimsResponse[]> {
  try {
    const results = await get(`markets/*/bets/*/claims`, { prompt: filter });
    return Array.isArray(results) ? results as MarketsBetsClaimsResponse[] : [];
  } catch (error) {
    console.error(`Error getting MarketsBetsClaims collection at path 'markets/${marketId}/bets/${betId}/claims': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in MarketsBetsClaims collection at markets/${marketId}/bets/${betId}/claims
 
  Read Operation Details: UI/API How-To:
Who: Anyone (audit/history).
Goal: View claim attempts.
  
 */
export function subscribeAllMarketsBetsClaims(callback: (data: MarketsBetsClaimsResponse[]) => void, marketId: string, betId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`markets/*/bets/*/claims`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as MarketsBetsClaimsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to MarketsBetsClaims collection at path '${`markets/*/bets/*/claims`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- End Generated SDK ---
